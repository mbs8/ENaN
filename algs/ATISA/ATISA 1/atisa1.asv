%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Aprendizagem de Máquina - CIn/UFPE - Engenharia da Computação           %
% ATISA 1                                                                 %                                                                   
%                                                                         %
% Sèrgio Renan Ferreira Vieira -  srfv@cin.ufpe.br                        % 
% Renan Hannouche Torres - rht@cin.ufpe.br                                %                                              
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

clc; clear;

data = load ('ionosphere.txt');
training = data(:, 1:(size(data, 2) - 1));
classTraining = data(:, size(data, 2)); %classes da bd ionosphere na última coluna

training = normal01 (training);
%Calcula-se as distâncias de cada instância para todas as outras do 
%mesmo conjunto
dists = distancias (training);

%Ordenação
[dists idx] = sort (dists, 2, 'ascend');
%excluimos a última coluna pq contém a distância da instância para ela
%mesma
dists = dists(:, 1:(size (dists, 2) - 1));
idx = idx(:, 1:(size (idx, 2) - 1));

tic

%PARTE 1: PRÉ-PROCESSAMENTO (EDITED NEAREST NEIGHBOR)
k = 3;
classMajority = mode (classTraining(idx(:, 1:k)), 2); %k-nn
tmp = classTraining == classMajority;
Tf = training(tmp, :);
Tf_class = classTraining(tmp); 

%Embaralhar instâncias de Tf
aux = randperm (size (Tf, 1));
Tf = Tf(aux, :);
Tf_class = Tf_class(aux, :);

%Cálculo das distâncias do Tf
Tf_dists = distancias (Tf); 
%ordenação
[t Tf_idx] = sort (Tf_dists, 2, 'ascend');
Tf_idx = Tf_idx(:, 1:(size (Tf_idx, 2) - 1));

%PARTE 2: ATRIBUIÇÃO DE LIMIARES
Tf_thresholds = threshold (Tf, Tf_class, Tf_idx);

%nova coluna que indica se a instância foi adcionada a S
Tf = [Tf (zeros (size (Tf, 1), 1))];
[l c] = size (Tf);
Tf(1, c) = 1;  %Tf(1) é adicionado a S automaticamente

%PARTE 3: GERAÇÃO DO CONJUNTO REDUZIDO
for i= 2:l
    %seleciona os índices das instâncias mais próxima que estão em S
    N = (Tf(Tf_idx(i, :), c)').*Tf_idx(i, :);
    N = N(N ~= 0);
    if (length (N) >= k)
        N = N(1:k);  %índices de N = k-nn (xi, S)
    end
    majorityClass = mode (Tf_class(N)); %classe_max (N)
    cd1 = Tf_class(i) ~= majorityClass;
    cd2 = mean (Tf_dists(i, N)) > mean (Tf_thresholds(N));
    Tf(i, c) = cd1 || cd2; %Se cd1 || cd2, então Tf(i) é adicionado em S
end

%Subconjunto das instâncias selecionadas a partir do conj. de treinamento
S = Tf((Tf(:, c) == 1), 1:(c - 1));
S_class = Tf_class((Tf(:, c) == 1));
        
r = 1 - (size (S, 1)/size (training, 1));
fprintf ('Reduçao de %1.2f%%\n', 100*r);

toc